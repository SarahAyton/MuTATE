#' MTPrune: Prune a Decision Tree Using Minimal Cost-Complexity Pruning
#'
#' Prune a MTPart decision tree object using minimal cost-complexity pruning based on the specified complexity parameter (CP) value.
#'
#' @param tree A decision tree object generated by a tree-building algorithm, such as `rpart` or `ctree`.
#' @param cp A numeric value specifying the complexity parameter (CP) threshold for pruning. Default is 0.02.
#'
#' @return A list with two elements:
#' \itemize{
#'   \item \code{partitions}: A data frame representing the pruned parent-child relationships and tree nodes.
#'   \item \code{tree_nodes}: A list of pruned decision tree objects, one for each node in the original tree.
#' }
#'
MTPrune <- function(tree, cp = 0.02){
  # Extract parent-child relationships & tree nodes
  df <- tree[[1]]
  df <- df[(2:nrow(df)),]
  df <- df[which(!is.na(df$parent)), c(1:2)]
  df$child <- gsub(" *\\*", "", df$child)
  mtpart_splits <- tree[[2]]
  # Split error & complexity table
  summarytree  <- MTPartSummary(tree)
  node_data    <- summarytree[[1]]
  summarytable <- summarytree[[2]]
  # Prune nodes if: CP < cp, then take min(xerror + xstd)
  cptable   <- data.frame(summarytable[c(2:nrow(summarytable)),])
  cptable$parent <- cptable$nsplit
  # Prune nodes if: CP < cp, then take min(xerror + xstd)
  cptable$keep <- as.integer(as.numeric(cptable$CP) >= cp)
  # Set all previous rows to 1 if keep value is 1
  cptable$keep[which(cummax(rev(cptable$keep)) > 0)] <- 1
  # Drop all rows where nsplit is equal to a parent value in df
  to_drop <- unique(c(cptable$nsplit[which(cptable$keep == 0)]))
  cptable <- cptable[which(cptable$keep != 0), c(1:ncol(cptable))]
  # Update parent-child table
  keepdf    <- df[which(!(df$parent %in% to_drop)), c(1:2)]
  child_list <- strsplit(keepdf$child, " ")
  first_child <- sapply(child_list, function(x) x[1])
  child_in_parent <- first_child %in% keepdf$parent
  keepdf$child[child_in_parent] <- keepdf$child[child_in_parent]
  keepdf$child[!child_in_parent & lengths(child_list) < 2] <- paste0(keepdf$child[!child_in_parent], " *")
  keepdf$child[!child_in_parent & lengths(child_list) >= 2] <- keepdf$child[!child_in_parent]
  keepdf$childid <- first_child
  # Update decision tree
  keepnodes <- lapply(1:length(mtpart_splits), function(n) {
    if (n %in% unique(keepdf$parent)) {
      mtpart_splits[[n]]
    } else if (n %in% as.numeric(keepdf$childid)) {
      split <- mtpart_splits[[n]]
      if (length(strsplit(split$NodeID, " ")[[1]]) < 2) {
        split$NodeID <- paste0(" ", split$NodeID)
      }
      split
    } else {
      NULL
    }
  })
  return(list(partitions = keepdf[,c(1:2)], tree_nodes = keepnodes)) #consider outputting eval directly instead of raw datasets
}
