#' MTPartSummary Function
#'
#' Extracts summary statistics from a decision tree.
#'
#' @param tree A list representing a decision tree generated by a tree-based
#'       algorithm in R.
#'
#' @return A matrix containing summary statistics including the number of splits,
#'         number of leaves, complexity parameter (CP), average relative error,
#'         total relative error, cross-validated error (Xerror), standard
#'         deviation of cross-validated error (Xstd), and evaluation metric (eval).
#'
#' @import dplyr
#' @import stats

MTPartSummary <- function(tree) {
  # Extract parent and child node IDs
  tree[[1]]$parent[1] <- 0
  parent <- tree[[1]]$parent
  parent <- parent[complete.cases(parent)]
  child <- gsub(" *\\*", "", tree[[1]]$child)
  child <- child[complete.cases(child)]

  # Replace NA values with 0
  tree[[2]] <- lapply(tree[[2]], function(x) {
    x[is.na(x)] <- 0
    x
  })

  # create data frame with node data
  node_data <- bind_rows(lapply(unique(as.numeric(child)), function(i) {
    data.frame(parent = floor(i/2), node = i,
               Partition = tree[[2]][[i]][["SplitVar"]], N = tree[[2]][[i]][["N"]],
               Pnode = tree[[2]][[i]][["Pnode"]], CP = tree[[2]][[i]][["CP"]],
               relerr = tree[[2]][[i]][["relerr"]], SXerror = tree[[2]][[i]][["SXerror"]])
  }))

  # Replace 0 with NA in CV and SXerror variables
  node_data$CP <- ifelse(node_data$CP == 0, NA, node_data$CP)
  node_data$SXerror <- ifelse(node_data$SXerror == 0, NA, node_data$SXerror)

  # Add nsplit and leaves columns to node data
  node_data <- node_data %>%
    mutate(nsplit = as.numeric(match(parent, unique(parent))-1),
           leaves = as.numeric(match(parent, unique(parent))))

  node_data$Pnode <- as.numeric(node_data$Pnode)

  # Initialize summary table
  summary_table <- matrix(ncol = 8, nrow = length(unique(parent)))
  colnames(summary_table) <- c("nsplit", "leaves", "CP", "AvgRelError", "TotRelError", "Xerror", "Xstd", "Eval")

  # Loop over parent nodes
  for (parent_node in unique(parent)) {
    df_temp <- tree[[1]][which(tree[[1]]$parent <= parent_node), c(1:2)]
    df_temp <- df_temp[!(df_temp$child %in% df_temp$parent), c(1:2)]
    # get all parents to include
    terminal_parents <- (df_temp$parent[(as.numeric(df_temp$parent) <= as.numeric(parent_node))])
    terminal_parents <- terminal_parents[complete.cases(terminal_parents)]
    # get all terminal child nodes for current tree
    child_nodes <- gsub(" *\\*", "", df_temp$child[as.numeric(df_temp$parent) <= as.numeric(parent_node)])
    child_nodes <- child_nodes[complete.cases(child_nodes)]
    # count number of partitions
    nsplit <- as.numeric(match(parent_node, unique(parent)))-1
    # count number of terminal nodes
    leaves <- length(child_nodes)
    if (parent_node == "0") {
      # compute average CP for all parent nodes of terminal leaves
      CP <- mean(node_data$CP[node_data$node %in% child_nodes] * node_data$Pnode[node_data$node %in% child_nodes])
      # compute average relative error for all terminal leaves with the current number of partitions
      AvgRelError <- mean(node_data$relerr[node_data$node %in% child_nodes] *
                            node_data$Pnode[node_data$node %in% child_nodes])
      # compute total relative error for all terminal leaves with the current number of partitions
      TotRelError <- sum(node_data$relerr[node_data$node %in% child_nodes] *
                           node_data$Pnode[node_data$node %in% child_nodes])
      # compute average cross-validated error for all parent nodes of terminal leaves
      Xerror <- 1
      # compute standard deviation of cross-validated error for all parent nodes of terminal leaves
      Xstd <- ifelse(!is.na(sd(node_data$SXerror[node_data$node %in% child_nodes] )),
                     sd(node_data$SXerror[node_data$node %in% child_nodes] ), 0)
      # compute evaluation metric
      eval <- Xerror + Xstd
    }
    else {
      # compute average CP for all parent nodes of terminal leaves
      CP <- mean(node_data$CP[node_data$node %in% terminal_parents] * node_data$Pnode[node_data$node %in% terminal_parents])
      # compute average relative error for all terminal leaves with the current number of partitions
      AvgRelError <- mean(node_data$relerr[node_data$node %in% child_nodes] *
                            node_data$Pnode[node_data$node %in% child_nodes])
      # compute total relative error for all terminal leaves with the current number of partitions
      TotRelError <- sum(node_data$relerr[node_data$node %in% child_nodes] *
                           node_data$Pnode[node_data$node %in% child_nodes])
      # compute average cross-validated error for all parent nodes of terminal leaves
      Xerror <- mean(node_data$SXerror[node_data$node %in% terminal_parents] *
                       node_data$Pnode[node_data$node %in% terminal_parents])
      # compute standard deviation of cross-validated error for all parent nodes of terminal leaves
      Xstd <- ifelse(!is.na(sd(node_data$SXerror[node_data$node %in% terminal_parents] )),
                     sd(node_data$SXerror[node_data$node %in% terminal_parents] ), 0)
      # compute evaluation metric
      eval <- Xerror + Xstd
    }

    # add summary data to table
    summary_table[(as.numeric(match(parent_node, unique(parent)))),] <- c(nsplit, leaves, CP, AvgRelError, TotRelError, Xerror, Xstd, eval)
  }

  # return node data and summary table
  return(list(node_data = node_data, summary_table = as.data.frame(summary_table)))
}
